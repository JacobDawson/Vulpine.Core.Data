using System;

namespace Vulpine.Core.Data.Exceptions
{
    /// <summary>
    /// A duplicate exception usual occors when the user tries to insert an object
    /// into a data structor, which dose not allow duplicate item, but already
    /// contains an item similar to the inserted item. It passes on the suspected
    /// duplicate, in case there was an error in the comparison.
    /// </summary>
    /// <remarks>Last Update: 2014-01-02</remarks>
    public sealed class DuplicateValExcp : DataStruckExcp
    {
        #region Class Definitions...

        /// <summary>
        /// The default message generated by a duplicate exception, prior to 
        /// applying any special case formating.
        /// </summary>
        public const string MSG = "The given object <{0}> has colided with "
            + "the internal object <{1}>. ";


        //stores a refrence to the duplicate item
        private object actual;
        private object duplicate;

        /// <summary>
        /// Creates a new duplicate exception, forwarding the pair of
        /// items that caused the exception, even if the two items are
        /// not identical.
        /// </summary>
        /// <param name="act">Actual object that caused the exception</param>
        /// <param name="dup">Suspected duplcate of the actual object</param>
        private DuplicateValExcp(object act, object dup) : base()
        {
            this.actual = act;
            this.duplicate = dup;
        }

        #endregion /////////////////////////////////////////////////////////////////////

        #region Class Properties...

        /// <summary>
        /// Generates a custom message, indicating the suspected duplicate
        /// object which caused the collision.
        /// Read-Only.
        /// </summary>
        public override string Message
        {
            get 
            {
                String a = (actual == null) ? "<null>" : actual.ToString();
                String b = (duplicate == null) ? "<null>" : duplicate.ToString();
                return String.Format(MSG, a, b); 
            }
        }

        /// <summary>
        /// The suspected duplicate item, which may be diffrent from the
        /// actual item, pending on the comparison method used.
        /// Read-Only
        /// </summary>
        public object Duplicate
        {
            get { return duplicate; }
        }

        /// <summary>
        /// The object that actualy caused the exception. It may be diffrent
        /// from the duplicate item, pending on the comparison method used.
        /// Read-Only
        /// </summary>
        public object Actual
        {
            get { return actual; }
        }

        #endregion /////////////////////////////////////////////////////////////////////

        #region Factory Methods...

        /// <summary>
        /// Generates a new Duplicate exception and throws it.
        /// </summary>
        /// <param name="act">The object that was given</param>
        /// <param name="dup">The suspected duplicate value</param>
        public static void Throw(object act, object dup)
        {
            //creates and throws the exception
            throw new DuplicateValExcp(act, dup);
        }

        /// <summary>
        /// Determins if two objects are considered to be equivlent based on
        /// some comparison method, and if they are, throw a duplicate exception. 
        /// Otherwise, it dose nothing.
        /// </summary>
        /// <param name="act">The object that was given</param>
        /// <param name="dup">The suspected duplicate value</param>
        /// <param name="comp">The method of comparison</param>
        public static void Check(object act, object dup, Comparison<Object> comp)
        {
            //if the objects are not the same, there is no exception
            if (comp(act, dup) != 0) return;

            //creates and throws the exception
            throw new DuplicateValExcp(act, dup);
        }

        /// <summary>
        /// Determins if two comparable objects are considered to be equivlent,
        /// and if they are, throw a duplicate exception. Otherwise, it dose
        /// nothing.
        /// </summary>
        /// <typeparam name="TItem">Type of the items</typeparam>
        /// <param name="act">The object that was given</param>
        /// <param name="dup">The suspected duplicate value</param>
        public static void Check<TItem>(TItem act, TItem dup)
            where TItem : IComparable<TItem>
        {
            //if the objects are not the same, there is no exception
            if (act.CompareTo(dup) != 0) return;

            //creates and throws the exception
            throw new DuplicateValExcp(act, dup);
        }

        #endregion /////////////////////////////////////////////////////////////////////
    }
}
